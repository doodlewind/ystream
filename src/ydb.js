import * as ops from './ops.js'
import * as Y from 'yjs'
import * as map from 'lib0/map'
import { setIfUndefined } from 'lib0/map.js'
import { bindydoc } from './bindydoc.js'
import * as env from 'lib0/environment'
import * as bc from 'lib0/broadcastchannel'
import * as promise from 'lib0/promise'
import * as buffer from 'lib0/buffer'
import * as isodb from 'isodb' // eslint-disable-line
import * as db from './db.js' // eslint-disable-line
import { Observable } from 'lib0/observable'

/**
 * @typedef {Object} YdbConf
 * @property {Array<import('./comm.js').CommConfiguration>} [YdbConf.comms]
 */

/**
 * @extends Observable<'sync'>
 */
export class Ydb extends Observable {
  /**
   * @param {string} dbname
   * @param {isodb.IDB<typeof db.def>} _db
   * @param {YdbConf} conf
   */
  constructor (dbname, _db, { comms = [] } = {}) {
    super()
    this.dbname = dbname
    /**
     * @type {isodb.IDB<typeof db.def>}
     */
    this.db = _db
    /**
     * @type {Map<string,Map<string,Set<Y.Doc>>>}
     */
    this.collections = new Map()
    /**
     * @type {Set<import('./comm.js').Comm>}
     */
    this.comms = new Set()
    this.whenSynced = promise.create(resolve => {
      this.once('sync', resolve)
    })
    comms.forEach(comm => {
      this.comms.add(comm.init(this))
    })
  }

  /**
   * @param {string} collection
   * @param {string} doc
   * @param {number} [opclock]
   */
  getUpdates (collection, doc, opclock) {
    return this.db.transact(tr =>
      tr.tables.oplog.indexes.doc.getValues({ start: new ops.DocKey(collection, doc, opclock == null ? 0 : (opclock + 1)) })
    )
  }

  /**
   * @param {string} collection
   * @param {string} doc
   * @param {Uint8Array} update
   */
  async addUpdate (collection, doc, update) {
    const op = await this.db.transact(async tr => {
      const op = new ops.OpValue(0, 0, collection, doc, new ops.YjsOp(update))
      const key = await tr.tables.oplog.add(op)
      op.clock = key.v
      return op
    })
    this.comms.forEach(comm => {
      comm.broadcast([op])
    })
  }

  /**
   * @todo this should be move to bindydoc.js
   * @param {Array<ops.OpValue>} ops
   */
  applyOps (ops) {
    this.db.transact(tr => {
      ops.forEach(op => {
        tr.tables.oplog.add(op)
      })
    })
    /**
     * @type {Map<string, Map<string, Array<ops.OpValue>>>}
     */
    const sorted = new Map()
    ops.forEach(op => {
      map.setIfUndefined(map.setIfUndefined(sorted, op.collection, map.create), op.doc, () => []).push(op)
    })
    sorted.forEach((col, colname) => {
      const docs = this.collections.get(colname)
      if (docs) {
        col.forEach((docupdates, docname) => {
          const docset = docs.get(docname)
          if ((docset && docset.size > 0) || env.isBrowser) {
            const mergedUpdate = Y.mergeUpdatesV2(docupdates.map(op => op.op.update))
            if (docset && docset.size > 0) {
              docset.forEach(doc => Y.applyUpdateV2(doc, mergedUpdate))
            }
            if (env.isBrowser) {
              // @todo could use more efficient encoding - allow Uint8Array in lib0/bc
              const mergedUpdate = Y.mergeUpdatesV2(ops.map(op => op.op.update))
              // @todo this should be generated by a function
              const bcroom = `${this.dbname}#${colname}#${docname}`
              bc.publish(bcroom, buffer.toBase64(mergedUpdate), this)
            }
          }
        })
      }
    })
  }

  /**
   * @param {string} collection
   * @param {string} docname
   */
  getYdoc (collection, docname) {
    const col = setIfUndefined(this.collections, collection, () => new Map())
    const docset = setIfUndefined(col, docname, () => new Set())
    const ydoc = new Y.Doc({
      guid: `${collection}#${docname}`
    })
    docset.add(ydoc)
    bindydoc(this, collection, docname, ydoc)
    return ydoc
  }

  destroy () {
    this.collections.forEach(collection => {
      collection.forEach(docs => {
        docs.forEach(doc => doc.destroy())
      })
    })
    return this.db.destroy()
  }
}
